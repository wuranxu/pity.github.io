> 大家好~我是`米洛`！<br/>
我正在从0到1打造一个开源的接口测试平台, 也在编写一套与之对应的完整`教程`，希望大家多多支持。<br/>
欢迎关注我的公众号`测试开发坑货`，获取最新文章教程! 

### 回顾

  上一节我们写好了一个`测试计划`的初级版本，并且能够添加计划，也能定时执行。那今天我们就来完善测试计划`删改查`与APScheduler相结合的部分。
  
### 定时任务和测试计划的耦合

  目前来看，测试计划和定时任务有着高度的耦合，考虑到我们`并不打算做一款自由度高的定时job系统`，所以暂时就先按这个思路设计。毕竟我们是一个做接口自动化的平台，而不是类似`jenkins`一样，有各类任务的平台。如果后续有相关的需求，我们再考虑。
  
  所以现在的情况是，定时任务列表存放了一批`job数据`，测试计划表又存放了与之对应的测试计划数据。
  
### 查询定时任务

  我们之前不是添加过一个定时任务吗？我们先来看看用APScheduler的api，获取到的数据内容。这时候就需要debug了~
  
  Scheduler对象是有个get_job的方法，我们之前给job的id定义为测试计划的id。
  
  所以我们现在可以用测试计划的id去查询定时任务的一些信息。
  
  在utils/scheduler.py新增list_test_plan方法:
  
```python
    @staticmethod
    def list_test_plan(data: List):
        for d in data:
            job = Scheduler.scheduler.get_job(str(d.get('id')))
            print(job)
            d["next_run"] = job.next_run_time
```

  传入的data是查询测试计划接口拿到的`测试计划数据`。

![](https://gitee.com/woodywrx/picture/raw/master/2021-11-6/1636166699222-image.png)

  过程如下:
  
1. 获取到测试计划数据
2. 根据测试计划数据去获取到定时任务的数据
3. 一并返回

![看看一个job返回的数据](https://gitee.com/woodywrx/picture/raw/master/2021-11-6/1636167413507-image.png)

  其实我这里弱化了定时任务的特点，反而把cron这样的字段剥离到`测试计划`之中了。所以这个定时任务给我们的作用就只有2个:
  
- 它是不是存在
- 它是否正常工作，可以通过next_run_at来判断

  所以我们只需要在查询接口，加上next_run_at就可以了。
  
![可以看到，我们是没有2这个测试计划的，所以查出来的job是None](https://gitee.com/woodywrx/picture/raw/master/2021-11-6/1636167597327-image.png)

  这点很重要，因为我们可能`创建测试计划成功`了，但`创建定时任务失败`了。所以这个数据不可忽略。
  
  当我们没获取到job的时候，把job的state改为2（并非在数据库改），只是在页面上显示这个测试计划任务未添加成功！！！
  
![获取定时计划的最终结果如下](https://gitee.com/woodywrx/picture/raw/master/2021-11-6/1636168136795-image.png)

### 编写编辑/删除定时任务方法

  由于APS本身就提供了良好的api，所以我们简易封装一下即可。
  
```python
    @staticmethod
    def edit_test_plan(plan_id, plan_name, cron):
        """
        通过测试计划id，更新测试计划任务的cron，name等数据
        :param plan_id:
        :param plan_name:
        :param cron:
        :return:
        """
        Scheduler.scheduler.modify_job(job_id=str(plan_id), trigger=CronTrigger.from_crontab(cron), name=plan_name)

    @staticmethod
    def pause_resume_test_plan(plan_id, status):
        """
        暂停或恢复测试计划，会影响到next_run_at
        :param plan_id:
        :param status:
        :return:
        """
        if status:
            Scheduler.scheduler.resume_job(job_id=str(plan_id))
        else:
            Scheduler.scheduler.pause_job(job_id=str(plan_id))

    @staticmethod
    def remove(plan_id):
        """
        删除job，当删除测试计划时，调用此方法
        :param plan_id:
        :return:
        """
        Scheduler.scheduler.remove_job(str(plan_id))
```

  这边已经都写好了`注释`，至于为什么我们需要`pause和resume方法呢`，是因为有时候我们可能不太想跑这个任务，我们想先暂停一下，所以有这个情况发生。
  
### 修改对应的接口

![红线部分是修改的地方，此外我们新增了一个switch接口，用于开关定时任务](https://gitee.com/woodywrx/picture/raw/master/2021-11-6/1636168423708-image.png)

  我们来测试下暂停功能:
  
- 暂停之前获取测试计划列表

![](https://gitee.com/woodywrx/picture/raw/master/2021-11-6/1636168504845-image.png)

- 暂停之后

![](https://gitee.com/woodywrx/picture/raw/master/2021-11-6/1636168580018-image.png)

  可以看到，由于next_run_at为None了，所以我们之前的strftime失效了。
  
  所以我们要做下调整:
  
![](https://gitee.com/woodywrx/picture/raw/master/2021-11-6/1636168761603-image.png)

  所以我们testplan有了3个状态:
  
- 0：等待中
- 1: 执行中
- 2: 定时任务未添加
- 3: 定时任务已暂停

  有了这些数据，我们前端就知道要怎么展示测试计划的定时任务状态了。
  
  下一节我们就要开始编写`测试计划页面`的前端部分了。