!!! Abstract 大家好~我是`米洛`！<br/>
> 我正在从0到1打造一个开源的接口测试平台, 也在编写一套与之对应的`教程`，希望大家多多支持。<br/>
> 欢迎关注我的公众号`米洛的测开日记`，获取最新文章教程! 

### 回顾

  上一节我们梳理了代理的难题，这一节就让我们来解决`证书下载`问题。其实可能这个功能不是很紧急，但起码目前pity要想做一个完整版的演示功能，这个功能是必不可少的。
  
### 找规律

  我们需要先找到各个证书的下载地址规律，从而根据`规律`拼凑出新的url。先挂上代理，然后看看对应的mitm.it：

![](http://oss.pity.fun/picture/20220623215627.png)

  注意这个后缀，分别是p12,pem和cer。接着我们来看看F12，对应的链接:

![](http://oss.pity.fun/picture/20220623215715.png)

  其实前面都是固定的，也就是:
  
```
http://mitm.it/cert/
```

  根据pem，p12等所有区分，所以我们写定对应的规律即可。话不多说，开始编码:
  
### 设置枚举类

  新建app/enums/CertEnum.py文件

```python
from enum import IntEnum


class CertType(IntEnum):
    windows = 0
    linux = 1
    macos = 2
    ios = 3
    android = 4

    def get_suffix(self):
        if self == CertType.windows:
            return "p12"
        if self in (CertType.linux, CertType.macos, CertType.ios):
            return "pem"
        if self == CertType.android:
            return "cer"
        raise Exception("unsupported cert type")

```
  
  除了定义windows这些枚举值以外，我们还需要把他们和pem/p12/cer对应起来，所以我们需要写一个get_url的方法，给他们自动`归类`。
  
### 编写下载证书接口

  修改app/routers/request/http.py，我们加入以下代码。

```python
@router.get("/cert")
async def http_request(cert: CertType):
    try:
        suffix = cert.get_suffix()
        client = AsyncRequest(CERT_URL + suffix)
        content = await client.download()
        shuffle = list(range(0, 9))
        random.shuffle(shuffle)
        filename = f"{''.join(map(lambda x: str(x), shuffle))}mitmproxy.{suffix}"
        with open(filename, 'wb') as f:
            f.write(content)
        return PityResponse.file(filename, f"mitmproxy.{suffix}")
    except Exception as e:
        return PityResponse.failed(e)
```

  首先我们先获取cert枚举，然后获取到对应的`后缀`，接着我们本地下载这个文件，随机生成文件名，最后写入并返回response。
  
  整个过程很简单，这里就不多介绍了。下面我们来看看前端部分。
  
### 编写前端

![](http://oss.pity.fun/picture/20220623220440.png)

  前端我们需要加入一个Dropdown(下拉菜单)，这样下拉能展示所有`类型`的证书，接着我们编写menu:

![](http://oss.pity.fun/picture/20220623220528.png)

  其实也就是5个链接，点击分别进入5个不同的url下载证书，我们来看看效果:

![](http://oss.pity.fun/picture/%E5%8A%A87.gif)

  
 证书我们是下载好了，接着我们拿到mac试试！~
 
### 测试mac

老规矩，我们先下载mac用的证书，接着信任之。
  

![](http://oss.pity.fun/picture/20220623234514.png)

  接着我们配置好http/https的代理，然后开启录制过程了~
  
![](http://oss.pity.fun/picture/20220623234607.png)

  这里其实不是本地哈，截图有点误差，没有显示url。

![](http://oss.pity.fun/picture/20220623234705.png)


  后续我又测试了`安卓`，(IOS很遗憾没搞定，我太菜了。。。）遗憾的是部分app并不能被抓到`请求`。
  
  上次我们那个录制的问题，是因为我们的`url`里面带有regex也就是具体的正则:
  
**start?regex=api.juejin.cn**

  所以也被误伤了，录制了下来，虽然挺不应该的。不过我们加一个，不录制包含pity.fun的url即可。

![](http://oss.pity.fun/picture/20220624003747.png)

  这样基本上就能解决录制的一大部分问题了，还有个`多设备`录制的问题，我们暂时先不解决，因为真的有点麻烦了。
  
  `大家有兴趣的可以进入pity.fun下载证书，安装后开启pity.fun,端口7778的代理，尝试录制用例啦~`