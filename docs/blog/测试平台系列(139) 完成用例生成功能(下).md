!!! Abstract 大家好~我是`米洛`！<br/>
> 我正在从0到1打造一个开源的接口测试平台, 也在编写一套与之对应的`教程`，希望大家多多支持。<br/>
> 欢迎关注我的公众号`米洛的测开日记`，获取最新文章教程! 

### 回顾

  上一节我们只捋了捋思路，并且迁移了一下枚举类以及制定了2个schema，这节我们就来完善剩下的。
  
### 完善CaseGenerator

  记得我们之前编写的CaseGenerator类吗，里面包括了RequestInfo生成，但还没有case生成部分。
  
  由于我们的case是由`CASE主体`以及`Constructors`，`断言`等组成，而我们默认是不带断言的，所以我们只需要生成case主体和构造方法即可。
  
- 获取bodyType  

  由于录制case的时候，我们根本不知道用户是什么请求类型，所以我们直接拿到RequestInfo数组的最后一个元素，根据里面Content-type来判断用例是什么类型。
  

![](http://oss.pity.fun/picture/20220617225853.png)
  
- 生成case主体

![](http://oss.pity.fun/picture/20220617225646.png)

  我这里固定好了用例名称为`录制用例`+对应的时间戳（防止重复），但其实后续我们会进一步升级，让用户生成用例的时候有一些选项。
  
  接着我们给一些用例的初始值，得到最终这个结果。
  
- 生成constructors

```python
    @staticmethod
    def generate_constructors(requests: List[RequestInfo]) -> List[ConstructorForm]:
        constructors = []
        for r in range(len(requests) - 1):
            name = f"http请求_{r + 1}"
            constructor_json = json.dumps(dict(
                body=requests[r].body,
                headers=requests[r].request_headers,
                base_path=None,
                url=requests[r].url,
                request_method=requests[r].request_method,
                body_type=CaseGenerator.get_body_type(requests[r].request_headers),
            ), ensure_ascii=False)
            c = ConstructorForm(name=name, value=f"http_res_{r + 1}", constructor_json=constructor_json,
                                enable=True, public=True, suffix=False, index=r + 1,
                                type=ConstructorType.http.value)
            constructors.append(c)
        return constructors
```
  
  代码比较简单，我们只遍历到request的N-1条数据，并把body等参数读取出来，成为一个constructor_json，最后生成一个ConstructorForm（这样能复用之前的新增用例方法）。
  
  至于前置条件的一些是否`公开`，`共享`等属性也默认打开了，这个其实无所谓，毕竟`用例生成了以后都是可以改的`。
  
- 编写生成用例接口

```python
@router.post("/generate", summary="生成用例")
async def generate_case(form: TestCaseGeneratorForm, user=Depends(Permission()), session=Depends(get_session)):
    if len(form.requests) == 0:
        return PityResponse.failed("无http请求，请检查参数")
    // 提取字段，更新数据
    CaseGenerator.extract_field(form.requests)
    cs = CaseGenerator.generate_case(form.directory_id, form.requests[-1])
    constructors = CaseGenerator.generate_constructors(form.requests)
    info = TestCaseInfo(constructor=constructors, case=cs)
    async with session.begin():
        ans = await TestCaseDao.insert_test_case(session, info, user['id'])
        return PityResponse.success(ans)
```

### 前端部分

  前端部分我们之前展示了具体生成的用例数据，这次的改动主要是以下2点:
  
1. 录制完后的表格数据要可以选择，不然录制到乱七八糟的，会影响用例生成
2. 生成用例后要可以给出链接跳转到对应的用例查看页

  话不多说，开造。
  
- service层 调用生成用例接口
  
```js
// 生成用例
export async function generateCase(data) {
  return request(`${CONFIG.URL}/testcase/generate`, {
    headers: auth.headers(),
    data,
    method: 'POST'
  });
}
```

- model层

![](http://oss.pity.fun/picture/20220617232532.png)

- jsx

![](http://oss.pity.fun/picture/20220617233548.png)

  调用生成case接口，接着我们先`强制`给一个directory_id=5，然后把选中的接口参数转换一下，发送给后端，最后拿到用例id即可。
  
  整体流程就是上述这样了，我们最后来看一个图。

![](http://oss.pity.fun/picture/%E5%8A%A822.gif)


  


