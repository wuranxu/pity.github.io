!!! Abstract 大家好~我是`米洛`！<br/>
> 我正在从0到1打造一个开源的接口测试平台, 也在编写一套与之对应的`教程`，希望大家多多支持。<br/>
> 欢迎关注我的公众号`米洛的测开日记`，一起交流学习! 

## 回顾

  上一节我们优化了下`测试报告`的内容。这一节我们来解决一个由来已久的历史bug，顺便弄清楚一下FastApi的启动机制。
  
  **本篇内容干货满满，希望大家可以耐心看完，然后给作者一个大大的拥抱。**
  
## 现象

  有同学反馈说`本地启动服务`的时候，接口文档页面打不开, 其实这个问题我也老早就知道了:
  
![](https://files.mdnice.com/user/11504/4a421106-d0ce-48ca-9f68-e174f3a8ade9.png)

  看起来是解析接口文档的时候遇到了问题，下面来说说我的`排查思路`。
  
### 1. 找到全局添加的异常

  我们找到全局添加的http`异常中间件`，在里面打印详细的堆栈信息:
  
  app\\_\_init\_\_.py文件
  
```python
@pity.middleware("http")
async def errors_handling(request: Request, call_next):
    body = await request.body()
    try:
        await set_body(request, await request.body())
        return await call_next(request)
    except Exception as exc:
        import traceback
        # 加上traceback,打印出详细的堆栈信息
        traceback.print_exc()
        return JSONResponse(
            status_code=status.HTTP_200_OK,
            content=jsonable_encoder({
                "code": 110,
                "msg": str(exc),
                "request_data": body,
            })
        )
```

  然后再次请求查看，发现有具体的报错信息了:
  
![](https://files.mdnice.com/user/11504/1f9f0910-4b20-4269-975e-12d9a8d53332.png)

  提示了我们key error，这看起来不是我们的代码，其实这个是解析你的所有路由里面请求model的方法，我们深入去查看一下:
  
![](https://files.mdnice.com/user/11504/149f902d-0505-4d08-a6de-c49b40c46148.png)

  也就是这一步，key error了，因为他用的是[]而不是.get，也没有任何`兜底`的操作。那我们看看为啥会KeyError，我们debug一下:

![加一个条件断点, 根据key的名字来](https://files.mdnice.com/user/11504/fd7b7eb1-88d1-4cad-8622-509ba89a3593.png)

  当model里面有avatar的时候我们进入断点, 让我们屏气凝神，再试一次:
  
![](https://files.mdnice.com/user/11504/faa4c1e6-991c-454e-ad55-456f8171d31b.png)

  可以看到，断点进来了。那我们来看看model_name_map里面的keys:
  
![](https://files.mdnice.com/user/11504/8d8f513d-3d2f-41c0-86bb-e8518781c4f8.png)

  可以看到，里面实际上是有这个数据的？（惊不惊喜意不意外）
  
  然后我们试一下取这个key:
  
![](https://files.mdnice.com/user/11504/78493337-9f65-4278-8230-527d33865982.png)

  果不其然，还是报错。那我们对比一下2个key，我们看到刚才key的索引是16，我们拉出来对比下:
  
![](https://files.mdnice.com/user/11504/79f5b9f7-829a-4a2e-b7d9-696318a9fc64.png)

  这2个class，看起来是一丝不差，给我也整懵逼了。
  
  ---
  
  等等，他这个key是class对象，不同的对象做key的话，可能会导致取不到哦。简单的说就是map里面的key ！= model。
  
  所以我们要考虑下为什么key不等于model，于是我们开始第二步排查。
  
### 2. 找找map生成的地方

  我们试着找下map生成的地方，看看它的key-value是怎么写进去的！
  
![](https://files.mdnice.com/user/11504/96c121f2-9491-4a98-952e-3860229c9067.png)

  根据堆栈一路找，可以看到他是根据flat_models解析出的map，我们看看flat_models：
  
![](https://files.mdnice.com/user/11504/c0767e5f-0cff-4d37-b7e9-d353c28ceaff.png)

  眼疾手快的我们，发现这个`flat_models`里面居然有2个一毛一样的model，那就可以解释了，key-value肯定是用的后面的那条数据作为key，而我们试着取前面那条数据。
  
  所以真相只有一个：我们这个数据重复了。
  
### 3. 是不是接口不小心注册了2次导致？

  仔细查看代码，发现并没有2份一样的接口。那会不会是路由重复注册了？那为什么其他的schema没有重复注册呢？
  
  我们来debug一下，这次，我们好好来，看routes部分:
  
![](https://files.mdnice.com/user/11504/e7512b1a-08d1-4087-a86d-26e1e6dacbeb.png)

  看到route有208个，我们应该没有这么多接口才对呀？这个模式不太好看，我们写个列表推导式see see:

![](https://files.mdnice.com/user/11504/e0c50556-d61a-4565-a176-6a9f5f4ac8c5.png)

  auth接口在前列，我们继续往下找找:
  
![](https://files.mdnice.com/user/11504/88b95bf5-262c-4f9a-9ff1-3142172175d8.png)

  发现这些接口又注册了一遍，好家伙，问题根源找到了，接口注册了2次，所有的都是。
  
### 4. 为什么接口注册了2次呢？

  回想一下我们启动app的时候，看看控制台:
  
![](https://files.mdnice.com/user/11504/d55ab8ef-2b1b-4de7-8f83-645b3ffd7169.png)

  我们没有开多个workers，但pity is running at pro 被执行了2次，我们找找项目里面的这块代码:
  
![](https://files.mdnice.com/user/11504/88c9777d-b35c-496d-944f-566dda0c2715.png)

  怎么搜也才出现1次，这可尴尬了。于是我们亲手在include_router那里打个断点，看到底会不会执行2次。
  
![第一次include](https://files.mdnice.com/user/11504/d42897d2-f9f2-49ed-8bc6-018895583161.png)

  我们按F9，继续调试代码
  
![](https://files.mdnice.com/user/11504/3bb25912-4825-400b-a91f-461d19b43b2e.png)

  发现断点又生效了，下面的日志也打印了2次。证明我们的猜想没错。
  
### 5. 求助

  这时候拿出各种搜索工具一通搜索，终于发现了这么个[地址](https://stackoverflow.com/questions/70300675/fastapi-uvicorn-run-always-create-3-instances-but-i-want-it-1-instance):
  
  
![](https://files.mdnice.com/user/11504/30725654-f271-4fc9-b170-e3f4dc3bb09e.png)

  他说他每次都执行3次（好家伙，比我还夸张），我们来看看别人的答复:
  
![](https://files.mdnice.com/user/11504/3c8b1ca1-b27a-4cfc-9ce6-0156e00c5229.png)

  简单的说就是，我们执行main.py，在到达__main__代码块之前，include已经执行一次了，接着我们调用的是:
  
![](https://files.mdnice.com/user/11504/3eba0626-baa2-4689-b26f-62d0f8ffed1a.png)

  它又会从main.py走一遭，也就是第二次执行。解决方案很简单，我们的启动文件不能放这些include的操作，只需要纯粹地执行代码即可。
  
```python
import uvicorn

if __name__ == "__main__":
    uvicorn.run("main:pity", host="0.0.0.0", port=7777, reload=False)
```

  所以我这边新建了一个runserver.py，并且写入了以上代码，我们来试试效果:
  
![](https://files.mdnice.com/user/11504/76255722-83dc-4074-9a1f-1b99c5f50903.png)

  可以看到，这块内容只打印一次了，我们最后试下打开/docs:
  
![](https://files.mdnice.com/user/11504/80eacad8-a036-4834-b94b-e80ef9af5c81.png)

  搞定，总体来说花了近2个小时排查+搜索问题，但总归是值得的！